# 电子书模块架构设计 (v3 - 精简版)

本文档基于“无会员系统、对接现有后端API，并复用现有通用服务”的核心约束，重新设计电子书功能模块。

---

### 一、业务目标与约束

**1. 业务目标:**
*   在现有应用中，构建一个功能完善且体验优秀的电子书阅读模块。
*   提供流畅的在线阅读、书籍管理和个性化阅读设置。
*   实现基础的离线阅读能力，允许用户下载章节后在无网络环境下阅读。

**2. 非目标:**
*   **会员系统:** 不涉及任何用户登录、付费、VIP等功能。
*   **社交功能:** 不包含评论、分享、笔记、书单等社交元素。
*   **用户原创内容 (UGC):** 不支持用户上传或导入本地电子书。
*   **独立数据库:** 不为电子书模块创建独立的本地数据库。

**3. 核心约束:**
*   **数据源:** 所有电子书数据（包括书籍列表、详情、章节内容）均通过调用现有的`backend/app.py`提供的API获取。
*   **UI/UX:**
    *   电子书分类/列表页面的布局与现有漫画页面保持一致，确保应用整体风格统一。
    *   阅读器界面需现代、简洁，并同时为移动端和桌面端优化。
*   **技术栈:** 使用Flutter和Riverpod进行开发，与项目现有技术栈保持一致。
*   **离线缓存:** 章节内容通过文件形式缓存，实现离线可用。
*   **服务复用:** 历史记录、收藏、下载管理功能将复用现有漫画/视频模块的通用服务。

---

### 二、系统边界与模块划分

新的电子书模块将由以下几个高度内聚的子模块构成：

1.  **数据层 (Data Layer) - 大幅简化**
    *   **职责:** 负责与后端API通信，获取原始数据，并将其解析为应用内的Dart数据模型。同时，管理文件缓存，负责离线章节内容的存储和读取。
    *   **核心组件:**
        *   `EbookRemoteService`: 封装所有与电子书相关的HTTP网络请求（如获取书籍列表、详情、章节内容）。
        *   `EbookFileCacheService`: 负责将下载的章节内容存为文件，并能根据章节ID读取文件。
        *   `EbookRepository`: 作为数据层的统一入口。当请求一个章节时，它会先检查`EbookFileCacheService`中是否存在对应的缓存文件。如果存在，则直接读取文件内容；如果不存在，则调用`EbookRemoteService`从API获取，并**异步**存入文件缓存。
        *   `EbookModels`: 定义所有电子书相关的Dart数据类（如`Ebook`, `Chapter`, `ChapterContent`）。

2.  **状态管理层 (State Management Layer) - 共享与复用**
    *   **职责:** 使用Riverpod管理电子书模块的UI状态，并与现有的通用服务进行交互。
    *   **核心组件 (`Providers`):**
        *   `ebookListProvider`: 提供电子书列表页的数据。
        *   `ebookDetailProvider`: 管理特定书籍的详情信息、章节列表以及下载状态。
        *   `ebookReaderProvider`: 管理阅读器页面的状态，包括当前章节内容、用户阅读偏好（字体、背景等）和阅读进度。
        *   `downloadManagerProvider`: (复用现有) 电子书的下载任务将适配并提交给现有的全局`DownloadManager`。
        *   `historyServiceProvider`, `favoriteServiceProvider`: (复用现有) 直接使用项目中已有的历史和收藏服务，将电子书作为一种新的内容类型添加进去。

3.  **UI展现层 (Presentation Layer)**
    *   **职责:** 负责渲染用户界面，响应用户操作，并将业务逻辑委托给状态管理层的`Providers`。
    *   **核心页面/组件:**
        *   **`EbookListPage`:** 电子书分类/列表页。通过`ebookListProvider`获取并展示书籍卡片。
        *   **`EbookDetailPage`:** 电子书详情页。
            *   展示书籍元数据（封面、作者、简介）。
            *   提供“整本下载”和“开始阅读”按钮。
            *   使用**卡片式网格布局**展示章节列表，每个卡片都应有独立的下载状态指示器和下载按钮。
        *   **`EbookReaderPage`:** 电子书阅读器。
            *   **内容渲染区:** 高效渲染文本内容，并支持智能分段。
            *   **目录侧边栏 (`ChapterDrawer`):** 展示所有章节，高亮当前章节，并支持点击跳转。
            *   **设置面板 (`SettingsPanel`):** 以底部弹出层的形式提供字体、背景、行距、列宽等设置项。
            *   **控制栏 (`ReaderControls`):** 在用户点击屏幕时浮现，提供返回、目录、设置等快捷入口。

---

### 三、核心数据流 / 调用链

1.  **阅读流程 (在线/离线无缝切换):**
    *   用户点击章节 -> `chapterContentProvider`调用`EbookRepository`。
    *   `EbookRepository`检查文件缓存：
        *   **命中缓存:** `EbookFileCacheService`读取文件 -> 返回内容。
        *   **未命中缓存:** `EbookRemoteService`从API获取内容 -> 返回内容给UI -> `EbookFileCacheService`在后台保存文件。

2.  **下载流程 (集成现有体系):**
    *   用户点击“下载” -> UI调用一个**适配器**方法。
    *   该适配器创建一个符合现有下载管理器要求的`DownloadTask`对象，其内部封装了获取电子书章节的逻辑。
    *   将此`Task`提交给全局的`DownloadManager`。后续的下载进度、状态更新都由这个全局管理器负责。

3.  **收藏/历史记录流程:**
    *   用户点击“收藏”或阅读超过一定时长 -> UI调用全局的`FavoriteService`或`HistoryService`的`add()`方法，传入书籍ID和类型（`ContentType.ebook`）。

---

### 四、关键风险点

1.  **适配器逻辑的复杂性:**
    *   **风险:** 将电子书的下载、历史、收藏逻辑适配到现有通用服务中，可能需要编写复杂的转换和适配代码。
    *   **应对:** 在动手前，先仔细阅读`downloadManager.js`、`database.js` (`history`/`favorite`相关部分) 的源码，清晰地定义出`Ebook`需要满足的接口或数据结构，再编写适配器。

2.  **文件系统管理的健壮性:**
    *   **风险:** 文件读写权限、存储空间不足、目录管理混乱等问题可能导致离线功能不稳定。
    *   **应对:** 使用成熟的路径管理库（如`path_provider`）来获取应用的安全存储目录。在写入文件前检查存储空间。为不同书籍创建独立的子目录，避免文件名冲突。

3.  **文本渲染与分页:**
    *   **风险:** 对于非常长的章节，一次性将所有文本加载到单个`Text`小部件中会导致严重的性能问题。
    *   **应对:** 实现一个高效的分页算法。在加载章节内容后，在后台（`Isolate`）将其预先计算分割成多个页面（`List<String>`），阅读器每次只渲染当前页面的文本。左右滑动或点击时切换页面索引。

4.  **状态管理与UI同步:**
    *   **风险:** 下载状态、阅读进度、用户设置等多种状态需要跨页面、跨模块同步，容易导致UI不一致。
    *   **应对:** 严格遵循Riverpod的最佳实践。所有可变状态都必须由`Provider`管理。UI层绝不直接修改状态，而是通过调用`Provider`的`notifier`方法来触发状态更新，确保数据流的单向和可预测性。

---

### 五、最小可行架构 (MVA - v3)

这个新方向的MVA将更聚焦于**集成**而非**创造**。

1.  **【第一步：API服务与模型】**
    *   创建`ebook.dart`模型。
    *   创建`EbookRemoteService`并实现API调用。

2.  **【第二步：打通在线阅读】**
    *   创建`ebookListProvider`, `ebookDetailProvider`, `chapterContentProvider`。
    *   创建`EbookListPage`, `EbookDetailPage`, `EbookReaderPage`三个页面的骨架。
    *   实现从列表页点击进入详情页，再点击章节进入阅读页并能**在线显示文本**的核心流程。

3.  **【第三步：集成历史记录】**
    *   在`EbookReaderPage`中，当页面加载时，调用现有的`HistoryService`来记录阅读历史。

这个MVA将快速验证我们能否将电子书作为一个新的内容类型，无缝地集成到现有应用的核心服务中。
