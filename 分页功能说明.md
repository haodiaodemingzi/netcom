# 分页加载功能说明

## ✅ 功能状态

后端和前端都已经支持分页加载功能！

## 后端支持

### API 端点
所有列表类接口都支持分页参数：

```
GET /comics/hot?page=1&limit=20&source=xmanhua
GET /comics/latest?page=1&limit=20&source=xmanhua
GET /comics/category?category=31&page=1&limit=20&source=xmanhua
```

### 参数说明
- `page`: 页码，从 1 开始（默认：1）
- `limit`: 每页数量（默认：20）
- `source`: 数据源（默认：xmanhua）
- `category`: 分类ID（仅分类接口需要）

### 返回格式
```json
{
  "comics": [...],
  "hasMore": true,
  "total": 20,
  "page": 1,
  "limit": 20
}
```

- `hasMore`: 是否还有更多数据（如果返回数 >= limit 则为 true）
- `total`: 本页返回的漫画数量
- `page`: 当前页码
- `limit`: 每页限制数量

### 实现原理

#### Xmanhua 数据源
URL 格式：`https://xmanhua.com/manga-list-{category_id}-0-10-p{page}/`

例如：
- 第1页：`/manga-list-31-0-10-p1/`
- 第2页：`/manga-list-31-0-10-p2/`
- 第3页：`/manga-list-31-0-10-p3/`

## 前端实现

### 状态管理
```javascript
const [page, setPage] = useState(1);
const [hasMore, setHasMore] = useState(true);
const [comics, setComics] = useState([]);
const [loading, setLoading] = useState(false);
```

### 加载逻辑

#### 1. 初始加载/切换分类
```javascript
useEffect(() => {
  if (initialized && currentSource) {
    setPage(1);           // 重置页码
    setComics([]);        // 清空数据
    loadComics(true);     // 加载第一页
  }
}, [selectedCategory, currentSource, initialized]);
```

#### 2. 上拉加载更多
```javascript
useEffect(() => {
  if (initialized && currentSource && page > 1) {
    loadComics(false);  // 加载下一页并追加
  }
}, [page]);

const handleLoadMore = () => {
  if (!loading && hasMore) {
    setPage(prevPage => prevPage + 1);
  }
};
```

#### 3. 数据加载
```javascript
const loadComics = async (isRefresh = false) => {
  setLoading(true);
  const currentPage = isRefresh ? 1 : page;

  try {
    const data = await getComicsByCategory(category, currentPage, 20, source);
    
    if (isRefresh) {
      setComics(data.comics || []);
    } else {
      setComics([...comics, ...(data.comics || [])]);
    }
    
    setHasMore(data.hasMore || false);
  } finally {
    setLoading(false);
  }
};
```

### UI 组件

#### FlatList 配置
```javascript
<FlatList
  data={comics}
  renderItem={renderItem}
  onEndReached={handleLoadMore}
  onEndReachedThreshold={0.5}
  ListFooterComponent={renderFooter}
/>
```

#### 底部加载指示器
```javascript
const renderFooter = () => {
  if (!loading || comics.length === 0) return null;
  
  return (
    <View style={styles.footerLoading}>
      <ActivityIndicator size="small" color="#6200EE" />
      <Text style={styles.footerText}>加载中...</Text>
    </View>
  );
};
```

## 用户体验

1. **首次进入**：显示前20条数据
2. **下滑到底部**：自动触发加载更多
3. **底部显示**："加载中..." 提示
4. **追加数据**：新数据追加到列表末尾
5. **没有更多**：`hasMore = false` 时停止加载
6. **切换分类**：重置到第1页，重新开始

## 测试建议

### 后端测试
```bash
# 测试第1页
curl "http://localhost:5000/api/comics/category?category=31&page=1&limit=20&source=xmanhua"

# 测试第2页
curl "http://localhost:5000/api/comics/category?category=31&page=2&limit=20&source=xmanhua"

# 测试第3页
curl "http://localhost:5000/api/comics/category?category=31&page=3&limit=20&source=xmanhua"
```

### 前端测试
1. 打开首页，选择任意分类
2. 向下滑动到底部
3. 观察是否自动加载第2页
4. 继续滑动，测试第3页、第4页...
5. 切换分类，确认重置为第1页
6. 切换数据源，确认重置为第1页

## 注意事项

1. ⚠️ `hasMore` 判断逻辑：如果返回数 < limit，说明没有更多数据
2. ⚠️ 网站可能有总页数限制，超过一定页数后返回空数据
3. ⚠️ 确保 `onEndReachedThreshold` 合理（0.5 表示距离底部50%时触发）
4. ⚠️ 使用函数式更新避免闭包问题：`setPage(prevPage => prevPage + 1)`

## 已修复的问题

✅ 修复了页码变化不触发加载的问题
✅ 添加了底部加载指示器
✅ 优化了分类切换时的重置逻辑
✅ 添加了 `hasMore` 判断防止无效请求
